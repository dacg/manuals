import os, sysimport numpyimport mathimport randomimport copyfrom pylmgc90.pre import *if not os.path.isdir('./DATBOX'):    os.mkdir('./DATBOX')# parametres#  *on se place en 2Ddim = 2#creation des conteneurs#   * pour les corpsbodies = avatars()#   * pour les materiauxmat = materials()#   * pour les tables de visibilitesvs = see_tables()#   * pour les lois de contacttacts = tact_behavs()#creations de deux materiaux# Note : se sont en fait les memes materiaux, c'est juste pour differencier grains et paroistdur = material(name='TDURx',materialType='RIGID',density=2000.)plex = material(name='PLEXx',materialType='RIGID',density=2000.)mat.addMaterial(tdur,plex)#on cree un modele de rigidemod = model(name='rigid', physics='MECAx', element='Rxx2D', dimension=dim)# Number of particlesnb_particles = 10000 # multiples of (nb_family-1)# r_min and r_maxs=0.5d_ext_max = 15.  # 15 mm # Puntor_ext_max = d_ext_max/2. # Puntor_ext_min = r_ext_max*(1-s)/(1+s)# particle's family nb_family = 31psd_0 = np.zeros(nb_family)paso = (r_ext_max-r_ext_min)/(nb_family-1)for i in range(0,nb_family,1):  r =  r_ext_min + paso*i  psd_0[i] = r  #psd is the value of each radius not diameter #psd = np.zeros(nb_family-1)for i in range(0,len(psd_0)-1,1):   psd[i] = (psd_0[i]+psd_0[i+1])/2#print psd# on recupere le plus petit et le plus grand rayonradius_min=min(psd)radius_max=max(psd)#limit of lambdaLambda_max = 5.Lambda_min = 1. ######################################################## volume of each particlevol_psd = np.zeros(nb_family-1)for i in range(0,nb_family-1,1):  R_int = psd[i]  Lambda = (Lambda_min + (psd[i] - radius_min)/(radius_max-radius_min)*(Lambda_max-Lambda_min))  R_ext = R_int*Lambda  if (Lambda == 1.) :    vol_psd[i] = np.pi*R_int**2    if (Lambda > 1.) :    vol_psd[i] = np.pi*R_int**2 + 4*(R_ext-R_int)*R_int  ##print 'Caso V1'print psdprint vol_psd# calculate number of particles n = 0.num_psd = np.zeros(nb_family-1)while n < nb_particles:# or n > (1 - 0.05)*nb_particles :  num_psd[-1] += 1  for i in range(0,len(vol_psd),1):      number = np.around(vol_psd[-1]*num_psd[-1]/vol_psd[i])      num_psd[i] = number    #  n = np.sum(num_psd)#print num_psdprint 'number of particles', n#prepare vector radiiradii_0 = np.zeros(int(n))k=0for i in range(0,nb_family-1,1):  for j in range (0,int(num_psd[i]),1):     radii_0[k] = psd[i]     k +=1  ### calculate volumen errorerror = np.zeros(len(psd))for i in range (0,len(psd),1):   error[i] = abs(vol_psd[-1]*num_psd[-1]-vol_psd[i]*num_psd[i])/(vol_psd[-1]*num_psd[-1])sum_error = np.sum(error)print 'Total error is: ', sum_error########################################################random the list of radiusradii = np.asarray(random.sample(radii_0, len(radii_0)))Lambda = np.zeros(len(radii))radii_Lambda = np.zeros(len(radii))#velocity particles Vp = 0.05*(2.*radius_min)*(0.1)/5.e-4 #supose dt = 5e-4for i in range(len(radii)):  Lambda = (Lambda_min + (radii[i] - radius_min)/(radius_max-radius_min)*(Lambda_max-Lambda_min))  radii_Lambda[i] = radii[i]*Lambda## depot dans une boite rectangulairelx = 1800.ly = 1800.# Depositingfit_part = Falsetry_p = 0while not fit_part :  print (lx,ly)  #try_p += 1  # radii distribution  radii_c = copy.deepcopy(radii_Lambda)  #print (try_p)  #print (radii_c)  # This deposit can modify radii. That's why its created during each while  [nb_remaining_particles, coor] = depositInBox2D(radii_c,lx,ly)  if (nb_remaining_particles<n):#b_particles):    lx = lx*1.0005    ly = ly*1.0005    del nb_remaining_particles    del coor  else :    print ('Good size found')    print (lx)    print (ly)    fit_part = True  ##if (nb_remaining_particles < nb_particles):   print 'its need a more big box, because we have ', nb_remaining_particles, '!!!', '\n'#   *building the true shaped particles#       *boucle d'ajout des particules :for i in range(0,nb_remaining_particles,1):  # On recupere le rayon  Lambda = (Lambda_min + (radii[i] - radius_min)/(radius_max-radius_min)*(Lambda_max-Lambda_min))  R_ext = radii[i]*Lambda  R_int = radii[i] #      *Coordonnees du rectangle  S1x = R_int  S1y = R_ext - R_int  S2x =-R_int  S2y = R_ext - R_int  S3x =-R_int  S3y =-(R_ext - R_int)  S4x = R_int  S4y =-(R_ext - R_int)  #      *Coordonnee du disque superieur  D_down_x = 0  D_down_y = R_ext - R_int  #      *Coordonnee du disque inferieur  D_up_x = 0  D_up_y = -(R_ext - R_int)  #      *Rayon des deux petits disques que l'on ajoute  Diam_circle = R_int  #      *On construit le grain  body = avatar(dimension=2)  body.addBulk( rigid2d() )  body.addNode( node(coor=coor[2*i : 2*(i + 1)],number=1) )  body.defineGroups()  body.defineModel(model=mod)  body.defineMaterial(material=tdur)  if (Lambda == 1.) :    #body.addContactors(shape='DISKx', color='BLUEx', byrd=radius)    body.addContactors(shape='DISKx', color='BLUEx', byrd=R_int)  if (Lambda > 1.) :    body.addContactors(shape='POLYG',nb_vertices=4,vertices=[[S1x,S1y],[S2x,S2y],[S3x,S3y],[S4x,S4y]],color='BLUEx')    body.addContactors(shape='DISKx', color='BLUEx', byrd=Diam_circle,shift=[D_up_x,D_up_y])    body.addContactors(shape='DISKx', color='BLUEx', byrd=Diam_circle,shift=[D_down_x,D_down_y])    body.computeRigidProperties()    # on tourne les grains de maniere aleatoire    body.rotate(psi=-random.uniform(0,6.28), center=body.nodes[1].coor)    #    #calculate initial velocity    body.imposeInitValue(component=1, value=((1-2*body.nodes[1].coor[0]/lx)*Vp)) #vel_x    body.imposeInitValue(component=2, value= (1-2*body.nodes[1].coor[1]/ly)*Vp) #vel_y  #  bodies += body  ############### creation des deux parois rugueuses, avec le materiau tdur# On construit les parois rugueusesdown = rigidJonc(axe1=1.5*lx, axe2=radius_min, center=[0.5*lx, -radius_min],                 model=mod, material=tdur, color='WALLx')up   = rigidJonc(axe1=1.5*lx, axe2=radius_min, center=[0.5*lx, lx + radius_min],                 model=mod, material=tdur, color='WALLx')left = rigidJonc(axe1=1.5*lx, axe2=radius_min, center=[-2*radius_min, 0.5*(lx + radius_min)],                 model=mod, material=tdur, color='WALLx')right= rigidJonc(axe1=1.5*lx, axe2=radius_min, center=[lx+2*radius_min, 0.5*(lx + radius_min)],                 model=mod, material=tdur, color='WALLx')# on ajoute les parois a la liste des corpsbodies += down; bodies += up; bodies += left; bodies += right# on tourne les parois verticales (par rapport a leur propres# centre d'inertie)left.rotate(psi=-math.pi/2., center=left.nodes[1].coor)right.rotate(psi=math.pi/2., center=right.nodes[1].coor)############## on impose les conditions aux limites sur chaque mur### compractation velocityv_ct = 10 #1.6e-6   #importante down.imposeDrivenDof(component=[1,3], dofty='vlocy')down.imposeInitValue(component=2, value=(Vp))  #impose inital value of velocity #down.imposeDrivenDof(component=2, dofty='force',ct=v_ct, )up.imposeDrivenDof(component=[1,3], dofty='vlocy')up.imposeInitValue(component=2, value=(-Vp))#up.imposeDrivenDof(component=2, dofty='force',ct=-v_ct)#right.imposeDrivenDof(component=1, dofty='force',ct=-v_ct)right.imposeDrivenDof(component=[2,3], dofty='vlocy')right.imposeInitValue(component=1, value=(-Vp))#left.imposeDrivenDof(component=1, dofty='force',ct=v_ct)left.imposeDrivenDof(component=[2,3], dofty='vlocy')left.imposeInitValue(component=1, value=(Vp))############## gestion des interactions :#   * declaration des lois#       - particules vs particules et particles vs paroislpartpart=tact_behav(name='iqsc1',law='IQS_CLB',fric=0.0)tacts+=lpartpartlpartjonc=tact_behav(name='iqsc0',law='IQS_CLB',fric=0.0)tacts+=lpartjonc#   * declaration des tables de visibilite#       - entre particules de type (polyg bleu) vs (polyg bleu)svdplpl = see_table(CorpsCandidat='RBDY2',candidat='POLYG',colorCandidat='BLUEx',behav=lpartpart,                    CorpsAntagoniste='RBDY2',antagoniste='POLYG',colorAntagoniste='BLUEx',alert=0.1*radius_min)svs+=svdplpl#       - entre particules de type (disk bleu) vs (disk bleu)svdkdk = see_table(CorpsCandidat='RBDY2',candidat='DISKx',                   colorCandidat='BLUEx',behav=lpartpart, CorpsAntagoniste='RBDY2',                   antagoniste='DISKx',colorAntagoniste='BLUEx',alert=0.1*radius_min)svs+=svdkdk#       - entre particules de type (disk bleu) vs (polyg bleu)svdkpl = see_table(CorpsCandidat='RBDY2',candidat='DISKx',                   colorCandidat='BLUEx',behav=lpartpart, CorpsAntagoniste='RBDY2',                   antagoniste='POLYG',colorAntagoniste='BLUEx',alert=0.1*radius_min)svs+=svdkpl#       - entre particules de type (disk bleu) vs (disk wall)svdkdkw = see_table(CorpsCandidat='RBDY2',candidat='DISKx',                   colorCandidat='BLUEx',behav=lpartjonc, CorpsAntagoniste='RBDY2',                   antagoniste='JONCx',colorAntagoniste='WALLx',alert=0.1*radius_min)svs+=svdkdkw#       - entre particules de type (polyg bleu) vs (disk wall)svdkplw = see_table(CorpsCandidat='RBDY2',candidat='POLYG',                   colorCandidat='BLUEx',behav=lpartjonc, CorpsAntagoniste='RBDY2',                   antagoniste='JONCx',colorAntagoniste='WALLx',alert=0.1*radius_min)svs+=svdkplw# ecriture des fichierswriteBodies(bodies,chemin='DATBOX/')writeBulkBehav(mat,dim=2,gravy=[0.,0.,0],chemin='DATBOX/')writeTactBehav(tacts,svs,chemin='DATBOX/')writeDrvDof(bodies,chemin='DATBOX/')writeDofIni(bodies,chemin='DATBOX/')writeVlocRlocIni(chemin='DATBOX/')print 'd_max :',max(radii*2), '\n', 'd_min :', min(radii*2), '\n', 'number of particles :', nb_remaining_particlesprint lx , ly#try:#  visuAvatars(bodies)#except:#  pass